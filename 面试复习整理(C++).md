# 面试复习整理(C++)

## C++和C的区别

1. 核心：C是面向过程的语言；C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；

```
面向过程：确定计算机应采取的操作后，使用编程语言实现这些操作。程序命令计算机按一系列流程生成特定的结果，像菜谱指定了厨师做菜的步骤。(程序难维护、难复用、难拓展，但性能高)
面向对象：把程序分解成一系列对象，每个对象既有自己的数据，也有处理这些数据的函数。不同对象分工协作完成程序，比如你去理发店，只需要提出要求，不需要教理发师怎么做。(易维护、易复用、易拓展，性能低)
```

2. 可以使用抽象数据类型进行面向对象编程；
3. 可以使用继承、多态进行面向对象的编程；

4. 可以担负起以模版为特征的泛型化编程。

## C++三大特性

### 封装

所谓封装就是将某些东西包装盒隐藏起来，让外界无法直接使用，只能通过某些特定的方式才能访问。使用者不必了解类内成员函数具体的实现细节，而只是通过调用接口的成员函数来访问类的成员。

体现在：

* 通过限制类内成员变量、成员函数的可访问性来实现。

***

### 多态

C++的多态体现在：在基类的函数前加上virtual关键字，在派生类中重新该函数，运行时会根据对象的实际类型去调用相应的函数。
体现在：

- 静态多态：允许函数重载和运算符重载，模板。
- 动态多态：虚函数。

---

### 继承

继承是面向对象的一个重要概念，如果一个类B继承自另一个类A，就把这个类B称为“A的子类”，而把A称为“B的父类”。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重新某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。



## 类的内联inline函数

定义：定义在类声明中的函数会自动成为内联函数（这样做的话，在每个使用这个类的文件中都会对内联函数进行定义）。也可以在别的地方定义，要在**定义**（而不是声明）前面加inline限定符号。

作用：当编译器发现某段代码在调用一个内联函数时，它不是去调用该函数，而是将该函数的代码，整段插入到当前位置。这样做的好处是省去了调用的过程，加快程序运行速度。（函数的调用过程，由于有前面所说的参数入栈等操作，所以总要多占用一些时间）。

缺点：每次调用都会插入一段代码，所以程序体积变大。

本质：节省时间但是消耗空间。

Tips：虚函数可以inline吗？inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略。

Tips2：一般有循环/递归的函数比较复杂，所以编译器会忽略inline。

## 类的拷贝构造函数

应用场景：

1. 一个对象作为函数参数，以值传递的方式传入函数体；
2. 一个对象作为函数返回值，以值传递的方式从函数返回；
3. 一个对象用于给另外一个对象进行初始化（常称为赋值初始化）；

```
Base a = b; (其中b也是一个Base类的对象)
```

重载拷贝构造函数：

```
class A{
    public:
    	A (const A & a); 
    	// 拷贝构造函数一定要传入引用，否则会自己调用自己，导致bug
};
```

默认的拷贝构造函数：浅拷贝，如果有指针，应该重构成深拷贝。

Tips：怎么禁用拷贝构造函数？

把拷贝构造设置成private，而且只声明不要定义它。

## 拷贝构造和operator =区别

```
Base a;　　　　 // 默认构造
Base b = a;　　// 拷贝构造
Base c(a);　　 // 拷贝构造
Base d;       // 默认构造
d = a;		// operator =
```

1. 定义会调用构造函数，赋值会调用operator =
2. 拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。



## 深拷贝和浅拷贝

浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。



## 类的内存分布

![image-20190321015424669](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190321015424669.png)

（如果是继承，先排父类数据，再排子类数据）

```
https://www.cnblogs.com/freeopen/p/5482965.html
```

多重继承：

非virtual继承：

基类：

![image-20190420024000313](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420024000313.png)

两个子类(同)：

![image-20190420024021481](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420024021481.png)

继承自两个子类的孙子类：

![image-20190420023837274](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420023837274.png)

可以看到有两个虚函数表+两个基类

virtual继承：

基类：无变化

两个子类(同)：

![image-20190420024142263](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420024142263.png)

![image-20190420030745691](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420030745691.png)

vbptr（虚基表）指向的值是8，即表示虚基类的偏移量，0+8刚好就是vfptr的位置。

孙子类：

![image-20190420030842915](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420030842915.png)

可以看到，有两个vbptr，偏移量指向的位置也是共同的基类20的位置。

构造函数的Tips：

```
D(int a,int b, int c, int d):B(a,b),C(a,c){
		this->d = d;
  	cout << "D constructor" << endl;
}
// 如果这样写构造函数，不会让B和C去构造A，而是调用A的默认构造函数(如果没有就报错)

D(int a,int b, int c, int d):A(a),B(a,b),C(a,c){
		this->d = d;
  	cout << "D constructor" << endl;
}
// 这样写的话A可以正常初始化，但是这时候B(a,b)这里的a已经没用
```



## 值传递、指针传递、引用传递

**值传递：**

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，

不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

**指针传递：**

形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作

**引用传递：**

形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈

中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过

栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

## 指针和引用的区别

它们都是地址的概念，其中指针指向一块内存，它的内容是所指内存的地址；而引用是某块内存的别名，具体来说，指针是一个变量的地址，引用是一个变量的别名。

不同：

1. 指针是一个实体，而引用仅是个别名；
2. 引用必须被初始化，指针不必；
3. 引用**只能在定义时被初始化一次**，之后不可变；指针可以改变所指的对象；
4. 不存在指向空值的引用，但是存在指向空值的指针，即引用不能为空，指针可以为空；
5. 程序为指针变量分配内存区域，引用同样也要分配内存区域（而且引用分配的空间也和指针一样）；“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

## const的用法

1. const修饰成员变量

```
const int * a4 = &a1;   ///const data,non-const pointer
int * const a5 = &a1;   ///non-const data,const pointer
int const * const a6 = &a1;   ///const data,const pointer
const int * const a7 = &a1;   ///const data,const pointer
```

- const位于*左侧，表示指针指向的数据是不能修改的，所以不能够通过解引用去修改数据（但是有可能可以直接让a1=xxx去修改，只是不能用这个指针去改）。但是指针可以指向别的内存单元。
- const位于*右侧，表明指针本身指向的地方是不能修改的，所以不能指向其他内存地址，但是可以用解引用修改地址的数据。
- 两侧都有，那就表示两者都不能修改。

2. const修饰函数参数

```
void func(const int x){
    x = 3; // 编译错误.
}
```

传递过来的参数在函数内不可以改变。

3. const修饰成员函数

```
class A{
	private:
		int x;
		mutable int y;
    public:
    	void func(void) const{
            // 在这个函数里面不能修改任何成员变量 除非这个成员变量有mutable
            this->x = 1; // 错误
            this->setX(); // 错误
            this->y = 1; // 正确 因为有mutable;
    	}
}
```

4. const修饰函数返回值

如果是指针传递：

```
const int * func(){
    ...
};
const int * a = func(); // 正确 此时a指向的东西不能改
int * b= func(); // 错误
```

如果是值传递：

```
const int func(){
    ...
};
```

函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。



Tips：const定义常量和define有什么区别？const定义的变量是执行时定义，define是预编译的时候直接替换。

## static的用法

1. 静态全局变量

   - 该变量在全局数据区分配内存；

   - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
   - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；（隐藏的作用）　

2. 静态局部变量：有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
   - 该变量在全局数据区分配内存；
   - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；如果没有显式初始化，会被程序自动初始化为0；
   - 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

3. 静态函数：

   ​	用static修饰的函数，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。
   　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：

4. 类内静态数据成员：类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。

   - 无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
   - 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

5. 静态成员函数：普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。
   - 出现在类体外的函数定义不能指定关键字static；
   - 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
   - 静态成员函数不能访问非静态成员函数和非静态数据成员；
   - 调用静态成员函数，可以直接使用＜类名＞::＜静态成员函数名＞（＜参数表＞），不需要实例化。



## dynamic_cast的用法以及别的cast区别

主要用途：

将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用**非虚函数**。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数。

前提条件：

当我们将dynamic_cast用于某种类型的指针或引用时，只有该类型含有虚函数时，才能进行这种转换。否则，编译器会报错。

实例：

```
// base要有虚函数
int main(){
    Base * first = new Base();
    Base * second = new Derived();

    cout << endl;

    Derived * third = dynamic_cast<Derived *>(first);
    if(third) cout << "Succeed" << endl;
    else cout << "Fail" << endl; 
    // 这里是fail 因为基类指针first指向的不是派生 如果是static_cast就是true

    Derived * fourth = dynamic_cast<Derived *>(second);
    if(fourth) cout << "Succeed" << endl; // 这里是success
    else cout << "Fail" << endl;

    return 0;
}
```



优缺点：

- dynamic_cast与一般强转的第一个区别就是，dynamic_cast应用的范围要更小一些，他只能对指针或者引用来进行强转。
- dynamic_cast多了一步安全的检查，基转基成功，派生转基成功，基转派生失败，返回空指针。（如果强制转换，可以基指针指向派生类）。

---

区别：

1. dynamic_cast 主要用于多态，为了执行“安全的向下转型（safe downcasting）”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。如上面例子。dynamic_cast转换的对象(源对象)必须有多态才可以成功。
2. static_cast 主要用于基础数据类型的转换，可以识别出比如char\*转int\*这种错误。也可以子转父。在父转子时也正常运行(但是这显然是不对的。所以不安全)。
3. const_cast 一般用于强制设置或消除对象的常量性。
4. reinterpret_cast能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。



## new/delete的用法

new为我们做了什么？

1. 在内存中开辟一块空间。  
2. 在开辟的空中中创建对象。  
3. 调用对象的构造函数进行初始化对象。   

new是否加括号：

```
（1）加括号
	1. 若括号为空，即无实参项，那么理解为调用默认构造函数；
	2. 若括号非空，即有实参项，可以理解为调用重载构造函数，或复合默认构造函数。
（2）不加括号
	调用默认构造函数，或复合默认构造函数。
```



编译器查找 new 和 delete 的顺序: 

```
1. 若操作对象是类类型, 则编译器首先在类或基类的作用域中查找. 若类中含 operator new (或 operator delete) 成员, 则调用这些成员.
2. 编译器在全局作用域中查找匹配的函数, 若有自定义版本, 则使用.
3. 若没找到, 则使用标准库定义的版本.
```



new operator和operator new：

new operator是new操作符，跟sizeof一样，不可以重载。它的功能总是一样的。它要完毕的功能分成两部分。第一部分是分配足够的内存以便容纳所需类型的对象。第二部分是它调用构造函数初始化内存中的对象。new操作符总是做这两件事情，你不能以不论什么方式改变它的行为。

new操作符调用一个函数来做必需的内存分配，你可以重写或重载这个函数来改变它的行为。**new操作符为分配内存所调用函数的名字是operator new**。如果new在类内重载，是隐式static的（因为在有对象之前，我们就能new了，所以应该是static）。



重载operator new（这里相当于一个函数，不能重载new operator）可以在分配完内存之后做一些自己的操作，比如给内存赋值之类的。



**在指定内存中新建对象**：placement new（本身就是对operator new的一种重载）

```
char* buf = new char[sizeof(A) * 3];//申请了3个A的内存
A* pc = new(buf)A(); //运用申请好的buf的内存,在buf上赋值
```



delete使用和new基本相似。首先调用析构函数，完成类成员的释放。再free掉整个对象的内存。



## extern的用法

实例：

头文件：state.h 源文件：state.cpp 
其它源文件：t1.cpp t2.cpp t3.cpp, 这些源文件都包含头文件state.h。 
需要定义一个全局变量供这些源文件中使用：方法如下 
1、在 state.h声明全局变量： extern int a; 
2、在state.cpp中定义该全局变量：int a = 10; 
这样其它源文件就可以使用该变量。

根据C++标准的规定，一个变量（注意是变量）声明必须同时满足两个条件，否则就是定义： 
(1)声明必须使用extern关键字；(2)不能给变量赋初值

```
extern int a; //声明 在.h

int a; //定义 在某一个.cpp/.h 有extern才是声明
int a = 0; //定义 
extern int a =0; //定义
```

头文件中应使用extern 关键字声明全局变量（不定义），如果这个变量有多个文件用到，可以新建一个cpp，在其中定义，把这个cpp加入工程即可（这样做就只有一个定义了）。

一般在头文件中申明，用extern, 在cpp中定义。 如果在头文件中定义，如果这个头文件被多个cpp引用，会造成**重复定义**的链接错误。

头文件只能申明全局变量（extern），不可定义（不推荐使用） .cpp里，在最外层定义即可，直接引用



## sizeof相关问题

sizeof(空类)：1个字节

sizeof(有虚函数表的类)：8个字节（64位机器指针8字节）

```
class Derived: public Base{
    public:
        virtual void fun(); 
    private:
        int a;
        char b;
        char c;
        double d;
};
首先虚函数表8；
此时8可以整除int，直接+4成12；
12可以整除char，直接+1；
13可以整除char，直接+1；
14不可以整除8，+2 +8变成24；
24可以整除最大的8，所以就24；
```

## 让函数在main函数之前执行的方法

1. 将要执行的代码写到类的构造函数中，并定义对应的全局变量

```
#include<iostream>
#include<Windows.h>
using namespace std;
class Debug{
public:
    Debug() {
        cout << "I am runing before main!" << endl;
    }
};

Debug t; // 全局变量

int main() {
    cout << "I am main!" << endl;
    return 0;
}

输出结果：
I am runing before main!
I am main!
```



## 虚函数

定义：用virtual关键字声明的函数叫做虚函数，虚函数一定是类内的成员函数。

---

意义：可以实现多态性，以共同的方法，但因个体差异，而采用不同的策略。

---

如果函数是虚函数，程序将根据引用/指针所指向的对象来选择方法。

```
Bass A(); // 其中function是虚函数
Derived B();
Bass & temp1 = A;
Bass & temp2 = B;
temp1.func(); // 调用A.func();
temp2.func(); // 调用B.func();
```

所以，一般析构函数都是虚函数，保证了可以正确的析构。

程序使用为对象类型定义的方法，而不使用为引用/指针类型定义的方法，这种称为动态联编或晚期联编。

---

工作原理：

编译器给每个对象添加了隐藏成员，这个隐藏成员保存了一个指向函数地址数组的指针。这个数组称为虚函数表（virtual function table，vtbl）。虚函数表中存储了类对象中声明的虚函数的地址。

例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类包含一个指向独立的地址表的指针。如果派生类提供了虚函数的新定义，那么该虚函数表保存新函数的地址，如果没有提供新定义，则保存函数原始版本的地址。如果派生类也新定义了虚函数，那么这个函数的地址也会添加到vtbl中。所以，无论虚函数有1个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不同。

调用虚函数时，程序会查看vtbl地址，然后转向相应的函数地址表。

---

缺点：在内存和执行速度方面需要成本。

- 包括每个对象都需要增大内存，用来保存函数的地址。
- 对于每个类，编译器都创建一个虚函数地址表。
- 每个函数调用时，都需要执行额外的操作，即在表中查找地址。（普通的函数可以在编译的时候直接定位到地址，不需要在虚函数表找）

---

### 纯虚函数

纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。

```
virtual <返回类型><函数名>(<参数列表>)=0; // 最后加一个=0即可
```

含有纯虚函数的类就是抽象类。C++不允许抽象类实例化对象。

---

构造函数和析构函数

构造函数：虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。（强行virtual编译不过）

析构函数：应该是虚的，这样，当通过指向对象的基类指针或引用来删除派生对象时，程序会调用派生类的析构函数，而不是仅仅调用基类的派生函数。

## 覆盖（重写）、重载、隐藏

覆盖（override）=重写（overwrite）：父子类中，函数名相同，参数列表相同，且有virtual修饰，只是实现的功能可能有所差别。（真正的多态）

重载（overload）：是指同一个类里面允许存在多个同名函数，而这些函数的参数表不同；（假多态，编译器会把同名的函数识别成不同名的函数）如果只有函数值不同，不能重载。

隐藏：父子类中，如果子类函数名与父类相同，而参数列表不同，无论有没有virtual，父类的同名函数都会被隐藏（无法调用）。(有一个例外是，如果基类虚函数返回值类型是基类，那么派生类返回值类型可以是派生类。这种叫 返回类型协变)

## 几种继承

（C++默认是private继承）

首先对于基类本身来说：

public：基类、友元、子类、外部都可以访问

private：基类、友元可以访问，子类、外部不可

protected：基类、友元、子类可以访问，外部不可

公有继承：基类的public和protected不变，除了基类的private没有人可以访问。

私有继承：基类的public和protected都变成了子类的private，所以只有子类自己和友元可以访问（子类的子类就不可以了）

保护继承：基类的public变成protected，protected不变

![image-20190314230309156](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190314230309156.png)

虚继承：virtual public/private Base...

假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于钻石（或者菱形），因此这个问题被形象地称为钻石问题（菱形继承问题）。此时类D有两个基类A的子对象。如果调用共有方法时，不知道是调用B的基类函数还是C的基类函数。所以出错。

在使用虚继承后，D就只有A的一份拷贝。

不使用虚继承：

![image-20190321025651314](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190321025651314.png)

可以看到有两个base class Base。

使用虚继承：

![image-20190321025845630](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190321025845630.png)

可以看到只有一个base了。变化是，虚继承的话，会先安排自己的子类数据，再排基类数据。而且还会增加一个基类的虚函数表。

---

### 继承的优缺点

优点：子类可以重写父类的方法来方便地实现对父类的扩展。

缺点：

1. 破坏了封装，父类的内部细节对子类是可见的。
2. 子类从父类继承下来的方法在编译时就确定了，无法改变。
3. 如果对父类方法进行修改（比如改了一个参数），则也要对子类方法进行修改，否则会触发隐藏。父类与子类高耦合，违背了面向对象的思想。

## 友元机制

友元(friend)机制允许一个类将对其非公有成员的访问权授予指定的函数或者类，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响（就是说你写在private或者public下面都一样）。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。

要注意：友元不能被继承。（父亲的朋友不一定是儿子的朋友，反之亦然）

## 内存

### new/delete和malloc/free的区别

相同点：都可用于申请动态内存和释放内存

区别：

1. 操作对象有所不同（本质区别）

malloc/free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类的对象而言，光用malloc/free无法满足动态对象的要求。因为，对象在创建的同时要自动执行构造函数，对象在消亡之前则要自动执行析构函数。由于malloc/free不是运算符，不受编译器的控制管辖，所以不能够把执行构造函数和析构函数的任务强加于malloc/free上。

2. 返回类型不同

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。

而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3. 内存分配失败时的返回值不同

内存分配失败时的返回值：new内存分配失败时，会抛出bac_alloc异常，比如反馈客户请求处理内存分配不足；malloc分配内存失败时返回NULL。

4. 是否需要指定内存大小

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。比如：(int *)malloc(sizeof(int))，new int;

5. 是否调用构造/析构函数

   new的过程：

   a、调用名为**operator new**的标准库函数，分配足够大的原始的未类型化的内存，以保存指定类型的一个对象

   b、运行该类型的一个**构造函数**去初始化对象

   c、返回指向新分配并构造的**构造函数**对象的**指针**

6. 是否可以被重载

   opeartor new /operator delete可以被重载，而malloc/free并不允许重载。

### 内存分布（5区）

C++内存分为5个区域（堆栈全常代 ）：

1. 堆 heap ：
   由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”
2. 栈 stack ：
   是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
   存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
3. 全局/静态存储区 （.bss段和.data段） ：
   全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。
4. 常量存储区 （.rodata段） ：
   存放常量，不允许修改（通过非正当手段也可以修改）
5. 代码区 （.text段） ：
   存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）



根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即

1. 自由存储区：局部非静态变量的存储区域，即平常所说的栈
2. 动态区： 用operator new ，malloc分配的内存，即平常所说的堆
3. 静态区：全局变量 静态变量 字符串常量存在位置

![image-20190318180849439](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190318180849439.png)

低地址
.text---> .data（已初始化） --->.bss（未初始化）--->heap(堆) --> unused <-- stack(栈)-->env（环境变量）

## 类的组合

在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。组合一般用来和继承比较。

继承的缺点：

1. 父类的内部细节对子类是可见的。

2. 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。

3. 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

优点：

1. 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
2. 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
3. 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

缺点：

1. 容易产生过多的对象；
2. 为了能组合多个对象，必须仔细对接口进行定义；

## STL

### vector

概述：

是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新值大于当前大小时才会重新分配内存。

特点：

- 拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符，但是由于它的内存空间是连续的，所以在头部和中间进行插入和删除操作会造成内存块的拷贝，另外，当该数组的内存空间不够时，需要重新申请一块足够大得内存并且进行内存的拷贝，这些都大大的影响了vector的效率。

  附内存分布图：

  ![image-20190318005834969](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190318005834969.png)

  如果capacity不足，会以原大小的两倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。

- 对头部和中间进行添加删除元素操作需要移动内存，如果你的元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高。头部和中间insert、erase时间复杂度为O(n)。尾部push_back、pop_back是O(1)。

- 对任何元素的访问时间都是O(1)，所以常用来保存需要经常进行随机访问的内容，并且最好不需要经常对中间元素进行添加删除操作。

- 对最后元素操作最快（在后面添加删除元素最快），此时一般不需要移动内存，只有保留内存不够时才需要。

总结：

- 需要经常随机访问且不用经常对中间元素删除插入时使用vector。
- 如果元素是结构或类，最好是将结构或类的指针放入vector中，这样不仅能够节省空间，而且可以避免移动时构造和析构操作。
- 删除元素时采用后面的元素覆盖前面的元素的方法可以提高效率。

Tips：

vector在拷贝的时候，不能直接使用=复制，需要迭代遍历所有元素一个一个复制。也可以重载=运算符。

Tipss：

vector不是线程安全的。因为在push_back的时候可能需要扩充容量，那么会把旧数据拷贝到新空间，此时对旧空间操作会导致线程不安全。解决方法：vector.reserve()方法分配足够的容量。

### map

概述：

都是无序的保存元素，只是通过它提供的借口对里面的元素进行访问，底层都是采用红黑树实现。

底层实现：红黑树

时间复杂度：

插入：O(logN)

查看：O(logN)

删除：O(logN)

### hash_map（就是unordered_map）

概述：

hash_map基于hash table（哈希表）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间。

结构：

```
template<typename K, typename V>  //每个节点的结构
	struct HashNode
	{
		pair<K, V> _kv;
		HashNode<K,V>* _next;
 
		HashNode(pair<K,V> p)
			:_next(NULL)
			, _kv(p)
		{}
	};
 
template<typename K, typename V, class HashFunc = _HashFunc<K>> //哈希表的结构，第三个参数是仿函数，为了实现可以存储string
	class HashTable
	{
	protected:
		vector<Node*> _table;
		size_t _size;
	};
```

1. 用一个vector来作为一个指针数组来存储节点的指针，_size来保存当前哈希表中的有效元素个数。

2. 由于是K/V结构，所以选择一个pair的结构来存储K/V。

3. vector中的每一个元素都指向一个链表，所有节点中需要一个next域的指针来指向下一个节点（采用单链表表结构）。

4. 采用模板来实现哈希表可以存储任意数据类型的目的

基本原理：

基本原理是：使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。

时间复杂度：

插入:O(1)，最坏情况O(N)

查看:O(1)，最坏情况O(N)

删除:O(1)，最坏情况O(N)

最坏情况=所有值都发生哈希冲突

### map和hash_map对比

1. 构造函数。hash_map需要hash函数，等于函数；map只需要比较函数(小于函数).
2. 存储结构。hash_map采用hash表存储，map一般采用红黑树实现。因此内存数据结构是不一样的。

总体来说，hash_map 查找速度会比map快，而且查找速度基本是常数级别；而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，如果你考虑时间效率，特别是在元素达到一定数量级时，可以考虑hash_map。

但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时（因为要额外存储哈希表需要更多内存），而且hash_map的构造速度较慢。

现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。

### list

结构

```
template<class T,class Alloc = alloc> //缺省使用alloc为配置器:w  
  class list{  
  protected :  
      typedef __list_node<T> list_node ;  
  public  :  
      typedef list_node* link_type ;  
  protected :  
      link_type node ; //只要一个指针指向end()，便可以表示整个环状双向链表  
      ...
  };


// 每个节点
template <class T>  
  struct __list_node {  
    typedef void* void_pointer;  
    void_pointer next;  
    void_pointer prev;  
    T data;  
  };  
```

双向链表。list不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要一个指针，便可以完整表现整个表。

所以不能随机访问，获取某个元素的复杂度是O(n)，插入到某个位置的复杂度是O(n)（如果插到最后就是O(1)，因为双向环装）。删除、find也是O(n)。

### deque

![image-20190412022907740](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190412022907740.png)

即map是连续的（跟上面的map不同），每个map指向不同的缓冲区。缓冲区内部也是一段连续的内存空间。

优点是如果既要随机存取（vector的优点）又要在两端push/pop（list的优点）就可以选用deque。缺点是占用内存大。

### queue和stack

这两个一般借用deque或者list去实现。不能用迭代器遍历。

### priority_queue

特点：自动排序（默认是从大到小，容器为vector，less）因为只有队头才能出，所以实现是类似一个最大堆/最小堆。

如果要改变排序方式可以：

```
//升序队列
priority_queue <int,vector<int>,greater<int> > q;
//降序队列
priority_queue <int,vector<int>,less<int> >q;
```

如果是自定义数据体，需要自己定义operator <。

## C++11

### Lambda表达式

用途：创建匿名函数

比如sort时候要写的operator <。

```
void abssort(float *x, unsigned N)
{
  std::sort(x,
            x + N,
            [](float a, float b) { return std::abs(a) < std::abs(b); });
}
```

### nullptr

以前用0表示空指针，但是这样不够安全，因为0也可以表达整型。所以使用了nullptr，它是指针类型，不能转换为整数类型。

nullptr==0 是true。

### 智能指针

背景：

程序new了内存后，不需要时应该delete释放。C++引入了auto_ptr，可以自动完成这个过程。但是C++11抛弃了auto_ptr，引入了unique_ptr和shared_ptr。智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。

auto_ptr和unique_ptr等的共同点：

可以将new获得的地址赋给这些指针，当指针过期的时候，它的析构函数将使用delete释放内存，不需要自己手动delete。

缺陷：

1. 如果有两个auto_ptr指向同一个对象，那么程序会试图delete两次，这是不对的，所以不能共享所有权。

2. auto_ptr要求其对“裸”指针的完全占有性。也就是说一个“裸”指针不能同时被两个以上的auto_ptr所拥有。那么，在拷贝构造或赋值操作时，我们必须作特殊的处理来保证这个特性。auto_ptr的做法是“所有权转移”，即拷贝或赋值的源对象将失去对“裸”指针的所有权。（我的理解是传入的是普通&，而不是const &，这样可以让原auto_ptr的指针指向空，就不会被误release）

   所以，拷贝或赋值的目标对象将先释放其原来所拥有的对象。

   ```
   int*p=new int(0);
   auto_ptr<int>ap1(p);
   auto_ptr<int>ap2=ap1;
   cout<<*ap1;//错误，此时ap1只剩一个null指针在手了
   ```

3. auto_ptr不能放在容器里面。STL容器在分配内存的时候，必须要能够拷贝构造容器的元素（比如vector，容量不够，就重新开空间去拷贝，此时需要一个const auto_ptr &的拷贝构造，所以报错）。

### unique_ptr

它提供了严格意义上的所有权，包括：

1. 拥有它指向的对象

2. 无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。（编译器报错）

```
unique_ptr<Test> fun()
{
    return unique_ptr<Test>(new Test("789"));
}

```

但是这种可以，因为里面的unique_ptr只是短暂停留。

```
void func1(unique_ptr<int> &up){
    cout<<*up<<endl;
}
 
//使用up作为参数
unique_ptr<int> up(new int(10));
 
//传引用，不拷贝，不涉及所有权的转移
func1(up);
```

3. 如果真的要使用两个智能指针赋值操作，应该使用std::move。

### share_ptr

资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

### weak_ptr

使用场景：

```
在Man类内部会引用一个Woman，Woman类内部也引用一个Man。当一个man和一个woman是夫妻的时候，他们直接就存在了相互引用问题。
man内部有个用于管理wife生命期的shared_ptr变量，也就是说wife必定是在husband去世之后才能去世。同样的，woman内部也有一个管理husband生命期的shared_ptr变量，也就是说husband必须在wife去世之后才能去世。
这就是循环引用存在的问题：husband的生命期由wife的生命期决定，wife的生命期由husband的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。
```

使用方法：

weak_ptr并不会改变它共享的shared_ptr实例的计数。那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。

那么怎么判断weak_ptr的对象是否还存在？

```
shared_ptr<A> sp(new A());
    weak_ptr<A> wp(sp);
    //sp.reset();

    if (shared_ptr<A> pa = wp.lock()) // 用lock方法 如果还在 返回一个s_ptr 否则返回空
    {
        cout << pa->a << endl;
    }
```



### 左值引用和右值引用

所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：

```
int i = 0;
```

在这条语句中，i 是左值，0 是字面量，就是右值。



```
int & rb = a+1; // 不能这么用，这里的a+1是右值
const int& r = val + 1; // 合法
```

左值引用：相当于把一个变量的地址付给另一个变量，这两个变量可以访问同一个内存，右值仅仅是一个数，而非内存中的某块地址，因此无法把右值复制给左值引用。



```
T && k = getVar();
```

　　只是相比第一行代码多了“&&”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。



实例：

```
A GetA()
{
    return A(); // construct1, return的时候再copy construct，然后delete自己
}

int main() {
    A a = GetA(); // return的值再copy给A，再delete自己
    return 0; // 最后A delete自己
}
结果：
construct: 1
copy construct: 1
destruct: 1
copy construct: 2
destruct: 2
destruct: 3
```

用了右值引用之后：

```
A GetA()
{
    return A(); // construct1, return的时候再copy construct，然后delete自己
}
int main() {
    A&& a = GetA(); // 这时候return的值不需要先copy再delete，直接把地址给A
    return 0;
}
输出结果：
construct: 1
copy construct: 1
destruct: 1
destruct: 2
```

右值引用特点：

1. 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。不需要频繁的构造/析构。
2. 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。
3. T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。

### std::move用法

c++11中提供了std::move()来将左值转换为右值引用，从而方便的使用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。 

```
int main()
{
    string str = "Hello";
    vector<string> v;
    
    //调用常规的拷贝构造函数，新建字符数组，拷贝数据
    v.push_back(str);
    
    std::cout << "After copy, str is \"" << str << "\"\n";
    
    //调用移动构造函数，掏空str，掏空后，最好不要使用str
    v.push_back(std::move(str));
    cout << "After move, str is \"" << str << "\"\n";
    cout << "The contents of the vector are \"" << v[0]
                                         << "\", \"" << v[1] << "\"\n";
}
```

![image-20190412025607148](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190412025607148.png)

如string类在赋值或者拷贝构造函数中会声明char数组来存放数据，然后把原string中的 char 数组被析构函数释放，如果str是一个临时变量，则上面的拷贝，析构就是多余的，完全可以把临时变量str中的数据直接 “转移” 到新的变量下面即可。