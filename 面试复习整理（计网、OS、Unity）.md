# 面试复习整理（计网、OS）

## 5层/7层网络协议

![image-20190420022531424](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190420022531424.png)





## TCP和UDP

### TCP

#### 三次握手

①客户端发送SYN包，请求建立连接，进入SYN_SENT状态，等待服务器确认。

②服务器收到SYN包，确认客户端的SYN（ack++），同时自己也发送一个SYN包，服务器进入SYN_RCVD状态。

③客户端收到服务器的SYN+ACK包，向服务器发送ACK包，发送完毕后，客户端和服务器进入成功连接状态，完成三次握手。

![image-20190415102917497](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190415102917497.png)

Q：第三次握手失败怎么办？

![image-20190319015842932](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190319015842932.png)

第58行指明了当第三次握手失败时的处理操作，可以看出当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。

Q：为什么不能用两次握手进行连接？

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

#### 四次挥手

①客户端发送FIN包，进入FIN_WAIT_1状态，等待来自服务器的确认报文。

②服务器接收到FIN包后，发送ACK包，进入CLOSE_WAIT状态。

③服务器等待一会后，向客户端发送FIN包，进入LAST_ACK状态。

④客户端接收到FIN包后，发送一个ACK包，进入TIME_WAIT状态，等待30秒后关闭，而服务器端收到这个ACK包后不发送，进入CLOSED状态。

Q：为什么需要四次挥手？

关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

Q：为什么客户端要TIME_WAIT等待2MSL（MSL为最大报文生命期）才关闭呢？

因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。



### 区别

1. 面向连接VS无连接
   TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手。另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放。
   UDP不需要建立连接，可以直接发起。

2. 可靠VS不可靠
   TCP利用三次握手四次挥手、序列号和ACK、超时重传机制、数据按一段段发送、

   1. 校验和（校验数据是否损坏，损坏了则让对方重发）；

   2. 定时器（超时重传机制）；

   3. 序列号（用于检测丢失的分组和重复的分组）；

   4. 确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；

   5. 否定确认（接收方通知发送方未被正确接收的分组）；

   6. 滑动窗口协议：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。

   7. 拥塞控制（拥塞窗口）：当网络拥塞时，减少数据的发送。

   ![image-20190415111543310](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190415111543310.png)

   一开始窗口<阈值，1-2-4-8（慢启动）；直到窗口>阈值，每次加一；如果拥塞，窗口变为1，重新慢启动，同时阈值变成拥塞值的一半。

3. 有序性
   TCP利用seq序列号对包进行排序，udp没有。

4. 面向字节流vs面向报文 
   - 面向报文
     面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。（一个upd的最大报文长度2^16-1-20-8,20是ip报文头，8是udp报文头）
   - 面向字节流
     面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

5. tcp有流量控制，udp没有

6. tcp的头部比20bytes，udp8byres

TCP应用场景：
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

UDP应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

## 进程和线程

进程：是并发执行的程序在执行过程中分配和管理资源（CPU、内存）的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

区别：

1. 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
2. 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu，也共享全局变量、静态变量等数据 ，但是进程之间的资源是独立的（所以一个进程崩溃别的不受影响，但是线程不行）。
3. 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
4. 线程是处理器调度的基本单位，但是进程不是。

优缺点：

　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。

　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。

---

何时使用多进程，何时使用多线程？

对资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

## 物理内存和虚拟内存

物理内存=CPU的地址线可以直接进行寻址的内存空间大小。

(小常识：32位计算机寻址为2^32字节，即4GB内存)

为什么会有虚拟内存和物理内存的区别：

​		正在运行的一个进程，他所需的内存是有可能大于内存条容量之和的，比如你的内存条是256M，你的程序却要创建一个2G的数据区，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。

## Unity的三个Update的区别

Update()每一帧的时间不固定，即第一帧与第二帧的时间t1和第三帧与第四帧的时间t2不一定相同。FixedUpdate()每帧与每帧之间相差的时间是固定的。

Update受当前渲染的物体影响，这与当前场景中正在被渲染的物体有关（比如人物的面数，个数等），有时快有时慢，帧率会变化，Update被调用的时间间隔就会发生变化。但是FixedUpdate则不受帧率的变化影响，它是以固定的时间间隔来被调用。

所以一些物理属性的更新操作应该放在FxiedUpdate中操作，比如Force，Collider，Rigidbody等。外设的操作也是，比如说键盘或者鼠标的输入输出Input，因为这样GameObject的物理表现的更平滑，更接近现实。

LateUpdate是在所有Update函数调用后被调用。可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。

 Unity后台主线程将 Update LateUpdate  制作成两个多线程 先去执行Update的线程，等Update 执行完毕后 在去执行LateUpdate线程。

因为多个update函数是先后顺序是随机的，所以可能摄像机先update而物体还未移动，而下一帧是若物体先update那么就会出现瞬移的情况。多数摄像机都要加上LateUpdate，即所有场景内的调用结束后再更新摄像机。