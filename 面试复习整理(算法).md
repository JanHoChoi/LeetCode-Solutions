# 面试复习整理(算法)

[TOC]

## 排序算法

### 插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序一般采用in-place实现，不需要额外空间。

```
1. 从第一个元素开始，这个元素认为已经被排序(只有一个)；
2. 取出下一个元素，在已经排好序的元素序列中，从后向前扫描；
3. 如果新元素<已排序的当前元素，则将当前元素向后移一个位置；
4. 重复步骤3，直到找到已排序的元素<=新元素的位置；
5. 将新元素插入到这个元素后面；
6. 重复2~5直到所有元素被排好；
```

```
vector<int> insertionSort(vector<int> arr){
    int size = arr.size();
    if(size == 0)
    	return arr;
    for(int i = 1; i < size; i++){
    	int cur = arr[i];
        int index = i-1;
        while(index >= 0 && arr[index] > cur){
            arr[index+1] = arr[index];
            index--;
        }
        arr[index+1] = cur;
    }
    return arr;
}
```

时间复杂度：最差情况，刚好倒序，则1+2+3....+n=O(n^2)。

空间复杂度：O(1)。

稳定。

### 选择排序

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

```
1. 初始状态：无序区为R[0..n]，有序区为空；
2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[0..i-1]和R[i..n]。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[0..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
3. n-1趟结束，数组有序化了。
```

```
vector<int> selectionSort(vector<int> arr){
    int size = arr.size();
    if(size == 0)
    	return arr;
    for(int i = 0; i < size; i++){
        int min_index = i;
    	for(int j = i; j < size; j++){
            if(arr[j] < arr[min_index])
                min_index = j;
        }
        swap(arr[i],arr[min_index]);
    }
    return arr;
}
```

时间复杂度：O(n^2)。

空间复杂度：O(1)。

不稳定：比如5 8 5 2 9，第一趟后，第一个5会被swap到第二个5的后面。

### 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

```
1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4, 重复步骤1~3，直到排序完成。
```

```
vector<int> bubbleSort(vector<int> arr){
    int n = arr.size();
    for(int i = 0; i < n-1; i++){
        for(int j = 0; j < n-i-1; j++){ // 注意范围
            if(arr[j] > arr[j+1]){
                swap(arr[j],arr[j+1]);
            }
        }
    }
    return arr;
}
```

时间复杂度：最坏情况下也是反序，所以O(n^2)。

空间复杂度：O(1)。

稳定。

### 希尔排序

希尔排序是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

```
1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。
```

```
vector<int> shellSort(vector<int> arr){
    int n = arr.size();
    for(int gap = n/2; gap > 0; gap = gap/2){
        for(int i = gap; i < n; i++){
            int cur = arr[i];
            int index = i-gap;
            while(index >= 0 && arr[index] > cur){
                arr[index+gap] = arr[index];
                index -= gap;
            }
            arr[index+gap] = cur;
        }
    }
    return arr;
}
```

时间复杂度：最坏情况还是O(n^2)，最好情况是O(n)，平均是O(n^1.3)；

空间复杂度：O(1)；

稳定性：不稳定，只有gap=1的时候的插入排序才保证稳定。

### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

```
1. 把长度为n的输入序列分成两个长度为n/2的子序列；
2. 对这两个子序列分别采用归并排序；
3. 将两个排序好的子序列合并成一个最终的排序序列。
```

```
void merge(vector<int> & arr, int start, int mid, int end){
    vector<int> res;
    int i = start,j = mid;
    while(i < mid && j < end){
        if(arr[i] <= arr[j]){
            res.push_back(arr[i]);
            i++;
        }
        else{
            res.push_back(arr[j]);
            j++;
        }
    }
    while(i < mid){
        res.push_back(arr[i]);
        i++;
    }
    while(j < end){
        res.push_back(arr[j]);
        j++;
    }
    for(int temp = start; temp < end; temp++){
        arr[temp] = res[temp-start];
    }
    return;
}

void mergeSort(vector<int>& arr, int start, int end){
    if(end - start <= 1) // 只有1个元素 直接返回
        return;
    int mid = (start+end)/2;
    mergeSort(arr,start,mid);
    mergeSort(arr,mid,end);
    merge(arr,start,mid,end);
    return;
}
```

时间复杂度：O(nlogn)；

空间复杂度：O(n)，只需要一个res在合并的时候存着。

稳定性：稳定。

### 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

```
1. 从数列中挑出一个元素，称为 “基准”（pivot）；
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
```

```
void quickSort(vector<int>& arr, int start, int end){
    if(end - start <= 1) // 只有1个元素 直接返回
        return;
    int first = start;
    int last = end-1;
    int key = arr[first];
    while(first < last){
        while(first < last && arr[last] >= key){
            last--;
        }
        arr[first] = arr[last]; // 赋值完之后不要自己first++
        while(first < last && arr[first] <= key){
            first++;
        }
        arr[last] = arr[first];
    }
    arr[first] = key; // pivot到位
    quickSort(arr,start,first);
    quickSort(arr,first+1,end);
    return;
}
```

时间复杂度：O(nlogn)。

空间复杂度：O(1)。

稳定性：不稳定。

最优情况：划分的均匀，此时递归深度为logn+1。

![image-20190320013125048](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190320013125048.png)

最差情况：如果划分不平衡，可能每次pivot都放在两侧，那么就是O(n + n-1 + n-2 ...) = O(n2)。

怎么避免最差情况：

1. 三平均分区法：不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。
2. 根据分区大小调整算法：当数据集较小时，不必继续递归调用快速排序算法，而改为调用其他的对于小规模数据集处理能力较强的排序算法来完成。

### 堆排序（最大堆）

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

最大堆：父节点元素>=子节点元素；最小堆：父节点元素<=子节点元素。

堆节点访问的一些常识：

1. 父节点i的左子节点位置在(2*i+1)；
2. 父节点i的右子节点位置在(2*i+2)；
3. 子节点i的父节点位置在(i-1)/2，向下取整；

```
1. 将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区
2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn)
3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。
4. 不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成
```

```
void max_heapify(vector<int> & nums, int start, int end){
    int dad = start;
    int son = dad * 2 + 1;
    while(son < end){
        if(son + 1 < end && nums[son] < nums[son+1])
            son++;
        if(nums[dad] > nums[son])
            return;
        else{
            swap(nums[dad],nums[son]);
            dad = son;
            son = dad*2 + 1;
        }
    }
    return;
}

void heapSort(vector<int> & nums){
    int len = nums.size();
    if(len <= 1)
        return; // 小于1个元素没意义排序
    
    // 构造最大堆
    for(int i = len/2 - 1; i>=0; i--){
        // 从最后一个父节点开始调整
        max_heapify(nums, i, len);
    }

    for(int i = len-1; i > 0; i--){
        swap(nums[0],nums[i]); // 把堆顶放在末尾
        max_heapify(nums, 0, i);
    }
    return;
}
```

时间复杂度：O(nlogn)。

空间复杂度：O(1)。

稳定性：不稳定。

### 基数排序

不进行关键字的比较,而是利用”分配”和”收集”。

有两种：①LSD（least significant digit），短的关键字认为是小的，排在前面。然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如1，2，3，4，5，6，7，8，9，10，11或者”b, c, d, e, f, g, h, i, j, ba” 。②MSD（most significant digit），直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如：1, 10, 2, 3, 4, 5, 6, 7, 8, 9和 “b, ba, c, d, e, f, g, h, i, j”。

```
1. 将根据整数的最右边数字将其扔进相应的0~9号的篮子里，对于相同的数字要保持其原来的相对顺序（确保排序算法的稳定性）
2. 将篮子里的数串起来，然后再进行第二趟的收集（按照第二位的数字进行收集），就这样不断的反复，当没有更多的位时，串起来的数字就是排好序的数字。
```

```
int maxbit(vector<int> & nums) //辅助函数，求数据的最大位数
{
    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < nums.size(); ++i)
    {
        while(nums[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;
}

void radixSort(vector<int> & nums) //基数排序
{
    int n = nums.size();
    int d = maxbit(nums); // 看看最大的数字有多少位
    vector<int> tmp(n);
    vector<int> count(10); //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (nums[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (nums[j] / radix) % 10;
            tmp[count[k] - 1] = nums[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            nums[j] = tmp[j];
        radix = radix * 10;
    }
}
```

时间复杂度：O (d(r+n))，其中r为所采取的基数（比如十进制就是10），而d为最大的位数。

空间复杂度：O(10n)。

稳定性：稳定

## 经典问题

### Tree

#### 镜像二叉树

给定一颗二叉树，构造它的镜像树。

```
// 递归
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL)
            return root;
        TreeNode* temp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(temp);
        return root;
    }
};

```



#### 二叉树深度

给定根节点，求这颗二叉树的深度。

```
// 递归做法
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == NULL)
            return 0;
        return max(TreeDepth(pRoot->left),TreeDepth(pRoot->right)) + 1;
    }
};
```

```
// 迭代做法
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == NULL)
            return 0;
        int res = 0;
        queue<TreeNode *> q;
        q.push(pRoot);
        q.push(NULL);
        while(!q.empty()){
            TreeNode * temp = q.front();
            q.pop();
            if(temp){
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);
            }
            else{ // 遇到NULL的时候，已经把所有的下一层节点全部入队
                res += 1;
                if(!q.empty()) q.push(NULL);
            }
        }
        return res;
    }
};
```

#### 判断是否是平衡二叉树

平衡二叉树定义：左右子树的高度差<=1，且左右子树自己也是平衡二叉树。

```
// 最直接方法
class Solution {
public:
    int getDepth(TreeNode * root){
        if(!root)
            return 0;
        return 1 + max(getDepth(root->left),getDepth(root->right));
    }
    bool IsBalanced_Solution(TreeNode* root) {
        if(!root)
            return true;
        return abs(getDepth(root->left)-getDepth(root->right)) <= 1 &&
            IsBalanced_Solution(root->left) && IsBalanced_Solution(root->right);
    }
};

// 缺点：子树的深度经常重复计算。
```

优化：增加剪枝，如果子树不满足要求，则直接剪枝。

```
class Solution {
public:
    int helper(TreeNode * root){ // 计算深度的同时，进行剪枝，如果返回值为-1，表明不符合要求
        if(!root) return 0;
        int left = helper(root->left);
        if(left == -1) return -1;
        int right = helper(root->right);
        if(right == -1) return -1;
        return abs(left - right) <= 1 ? max(left,right)+1 : -1;
    }
    bool IsBalanced_Solution(TreeNode* root) {
        if(!root)
            return true;
        return (helper(root) == -1) ? false : true;
    }
};
```

#### 二叉树中序遍历下的下一个结点

给定二叉树其中一个结点，找出中序遍历顺序的下一个节点。

```
// 这里pNode->left/right 指的是这个结点的左右子节点，pNode->next指的是父节点
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
    	// 主要有两种情况
    	// ①如果有右子树,那么下一个结点就是右子树的最左结点
    	// ②如果没有右子树,那么向上找父节点,要注意,如果当前节点是父节点的右结点,还要继续向上找,直到当前结点是父节点的左结点才可以。
        if(pNode->right){
            // 找右子树的最左节点
            TreeLinkNode * res = pNode->right; // 右子树的根节点
            while(res->left){
                res = res->left;
            } // 出循环时,res->left=NULL
            return res; 
        }
        else{
            while(pNode->next && pNode != pNode->next->left) // 如果pNode是父节点的左子节点
                pNode = pNode->next;
            return pNode->next;
        }
            return pNode->next;
    }
};
```

#### 按BFS从左到右方式输出二叉树的所有节点

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

```
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        q.push(NULL);
        while(!q.empty()){
            TreeNode * temp = q.front();
            q.pop();
            if(temp == NULL){
                if(!q.empty())
                    q.push(NULL);
            }
            else{
                res.push_back(temp->val);
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);
            }
        }
        return res;
    }
};
```

#### 根据前序序列和中序序列构建二叉树

比如前序是1245367，中序是4251637，要构造回一颗符合要求的树。

```
// 思路：递归方法，比如我们知道根节点肯定是1，所以在中序里面找1的位置，然后1左边的425即为左子树，右边的637为右子树。递归调用本身就可以。
class Solution {
public:
    TreeNode * helper(vector<int>& preorder, int pl, int pr, vector<int>& inorder, int il, int ir){
        if(pl >= pr) return nullptr;
        TreeNode * root = new TreeNode(preorder[pl]);
        // 找到根节点在中序的位置 计算出左子树有多长
        int left_length = find(inorder.begin()+il,inorder.begin()+ir,preorder[pl]) - inorder.begin() - il;

        root->left = helper(preorder,pl+1,pl+1+left_length,inorder,il,il+left_length);
        root->right = helper(preorder,pl+1+left_length,pr,inorder,il+1+left_length,ir);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return helper(preorder,0,preorder.size(),inorder,0,inorder.size());
    }
};
```

#### 判断二叉树有没有路径（从根节点到叶）的数值和等于某定值

```
// backtracking
class Solution {
public:

    void helper(vector<vector<int> > & res, vector<int> & solution, TreeNode* root, int sum){
        if(!root->left && !root->right){
            // 如果是叶子节点
            if(sum == 0){
                res.push_back(solution);
            }
        }
        if(root->left){
            solution.push_back(root->left->val);
            helper(res,solution,root->left,sum-root->left->val);
            solution.pop_back(); // 把左节点的pop出来
        }

        if(root->right){
            solution.push_back(root->right->val);
            helper(res,solution,root->right,sum-root->right->val);
            solution.pop_back();
        }
        return;
    }

    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<vector<int>> res;
        if(!root) return res;
        vector<int> solution;
        solution.push_back(root->val); // 已算上本身
        helper(res,solution,root,sum-root->val);
        return res;
    }
};
```

#### 把二叉搜索树重构成双向链表

即假设原来二叉搜索树为1,2,3,4,5,6,7其中1连23，2连45...

重构成1-2-3-4-5-6-7其中1-right = 2, 2-left=1。

思路：即把二叉搜索树按照中序遍历的序列重构

```
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        stack<TreeNode*> s;
        TreeNode * cur = pRootOfTree, * pre = nullptr, * res = nullptr;
        while(!s.empty() || cur){
            if(cur){ // 如果cur不是空节点 找他的最左
                s.push(cur);
                cur = cur->left;
            }
            else{ // 如果cur是空节点
                cur = s.top();
                s.pop();
                if(!pre){ // 无pre代表这个点是整棵树的最左叶
                    pre = cur; // 则这个点即为下个节点的pre 
                    res = cur; // 也是返回结果的第一个点                  
                }
                else{ // 有pre 则pre即为上一个节点
                    cur->left = pre;
                    pre->right = cur;
                    pre = cur;
                }
                
                // 到这里的时候,pre已经等于cur
                
                //每个pre的下一个节点都是它的右子树的最左节点
                // 也有可能cur->right为空，那么就返回上一层
                cur = cur->right; 
            }
        }
        return res;
    }
};
```



### 位运算

#### 不用+号实现加法

```
class Solution {
public:
    int Add(int num1, int num2)
    {
        while(num2 != 0){
            int temp1 = num1 ^ num2; // 如果在没有进位的情况下，异或和+其实是一样的
            int temp2 = num1 & num2; // 如果没有进位，则temp2应该是0
            
            // 所以num1 + num2 = temp1 + (temp2 << 1);
            // 在循环里一直走，直到没有进位
            
            num1 = temp1;
            num2 = temp2 << 1;
        }
        return num1;
    }
};
```



#### 判断数组是不是某二叉搜索树后序遍历

思路：后序遍历有一个特点，最后一个值是根节点，然后前面的数组分成两段，一段都比根节点小，另一段都比根节点大。所以递归。

```
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(sequence.empty()) return false;
        return helper(sequence,0,sequence.size()-1);
    }
    
    bool helper(vector<int> & sequence, int left, int right){
        if(left >= right)
            return true;
        int pivot = sequence[right]; // 最右边的值就是根节点
        int i = left;
        while(i < right){
            if(sequence[i] < pivot)
                i++;
            else
                break;
        }
        for(int j = i; j < right; j++){
            if(sequence[j] > pivot)
                continue;
            else
                return false;
        }
        return helper(sequence, left, i-1) && helper(sequence, i, right-1);
    }
};
```





#### 输入整数输出该整数二进制中1的个数

要注意：如果是负数的话。右移依然是补1，所以不能通过&1再右移去计算。

```
class Solution {
public:
     int  NumberOf1(int n) {
         int res = 0;
         int flag = 1;
         while(flag){
             if(flag & n) // 让1从最右位移向最左位 遍历所有位检查
                 res += 1;
             flag = flag << 1; // flag最后会变回0
         }
         return res;
     }
};
```



### 字符串

#### 字符串转整数

```
class Solution {
public:
    int StrToInt(string str) {
    	if(str.size() == 0)
    		return 0; // ①异常处理防止空字符串
        int res = 0;
        bool symbol = true;
        int i = 0;
        
        // ②判断符号位
        if(str[0] == '+'){
            symbol = true;
            i++;
        }
        else if(str[0] == '-'){
            symbol = false;
            i++;
        }
        else if(str[0] < '0' || str[0] > '9')
            return 0;
        
        while(i < str.size()){
            if(str[i] >= '0' && str[i] <= '9'){
                res *= 10;
                res += str[i] -'0';
            }
            else{
                return 0; // 不是数字均不合法
            }
            i++;
        }
        return symbol ? res : -res;
    }
};
```

#### 正则字符串匹配

'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。判断pattern字符串可不可以匹配s字符串。

```
// 递归做法
class Solution {
public:
    bool isMatch(string s, string p) {
    
        if(p.empty())
            return s.empty();
            
        // 如果p[1]是*
        // 那么① 无论p[0]和s[0]是否匹配, 只要p[2...]与s可以match即可, 此时*当做0次使用.
        // ② p[0]与s[0]匹配 则只要p与s[1...]可以match即可, *当做1次使用(*在后面还可以继续用).
        if(p[1] == '*')
            return isMatch(s,p.substr(2)) || 
            !s.empty() && (s[0] == p[0] || p[0] == '.') && isMatch(s.substr(1),p);
        
        // 如果p[1]不是*
        // 那么必须要p[0]与s[0]匹配 且s[1...]与p[1...]匹配
        else
            return !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1),p.substr(1));
    }
};
```

```
// 动态规划做法
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();

        // dp[i][j] 表示s[0...i-1] 与p[0...j-1]匹配
        vector<vector<bool> > dp(m+1, vector<bool>(n+1,false));

        // 初始化基本条件
        dp[0][0] = true; // 都为空true
        for(int i = 1; i <= m; i++){
            dp[i][0] = false; // s不为空 p为空 false
        }
        for(int j = 1; j <= n; j++){
            // 如果p[j-1]为*，且p[0...j-2]可以与空s匹配,那么true
            // 注意dp[0][1]一定为false
            dp[0][j] = j > 1 && dp[0][j-2] && p[j-1] == '*'; 
        }

        // 开始动态规划
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){

                // p[j-1]是*, 则要么
                // ①p[0...j-3]与s[0..i-1]匹配 此时*让p[j-2]使用0次
                // ②p[0...j-2]与s[0..i-1]匹配 即p[j-2]与s[i-1]匹配 且s[0...i-2]与p[0...j-3]匹配 即dp[i-1][j-2]
                // 又因为p[j-1]是*，所以即要dp[i-1][j]为true 此时*让p[j-2]使用1次以上
                if(p[j-1] == '*'){
                    dp[i][j] = dp[i][j-2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && dp[i-1][j];
                }

                // 如果p[j-1]不是*
                // 则只能让p[j-1]与s[i-1]匹配, 且p[0...j-2]与s[0...i-2]匹配
                else{
                    dp[i][j] = dp[i-1][j-1] && (p[j-1] == s[i-1] || p[j-1] == '.');
                }
            }
        }

        return dp[m][n];
    }
};
```

#### 判断字符串是否表示数值

![image-20190328004424625](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190328004424625.png)

思路：状态机DFA

![image-20190328004546847](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190328004546847.png)

```
class Solution {
public:
    bool isNumber(string s) {
        if(s.empty())
            return false;
        // 首先清理前后的空格
        while(s[0] == ' ')
            s = s.substr(1);
        while(s[s.size()-1] == ' ')
            s = s.substr(0,s.size()-1);
            
        int state = 0;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '+' || s[i] == '-'){
                if(state == 0) state = 1;
                else if(state == 4) state = 7;
                else return false;
            }
            else if(s[i] == '.'){
                if(state == 0 || state == 1) state = 3;
                else if(state == 2) state = 6;
                else return false;
            }
            else if(s[i] == 'e' || s[i] == 'E'){
                if(state == 2 || state == 6) state = 4;
                else return false;
            }
            else if(isdigit(s[i])){
                if(state == 0 || state == 1 || state == 2) state = 2;
                else if(state == 3 || state == 6) state = 6;
                else if(state == 4 || state == 5 || state == 7) state = 5;
                else return false;
            }
            else return false;
        }
        if(state == 2 || state == 5 || state == 6)
            return true;
        else
            return false;
    }
};
```

#### 字符串中找第一个不重复的char

```
class Solution {
public:
    int firstUniqChar(string s) {
        int hash[256] = {0};
        for(int i = 0; i < s.size(); i++){
            hash[s[i]]++;
        }
        for(int i = 0; i < s.size(); i++){
            if(hash[s[i]]==1)
                return i;
        }
        return -1;
    }
};
```

#### 替换空格

把字符串中的' '替换成'%20'。

```
class Solution {
public:
	void replaceSpace(char *str,int length) {
        int count = 0; // 统计空格数量
        for(int i = 0; i < length; i++)
            if(str[i] == ' ')
                count++;
        int new_length = length + 2*count;
        str[new_length] = '\0';
        int before = length - 1;
        int after = new_length - 1; // 从后面开始覆盖更好
        while(before >= 0){
            if(str[before] != ' '){
                str[after--] = str[before--];
            }
            else{
                str[after--] = '0';
                str[after--] = '2';
                str[after--] = '%';
                before--;
            }
        }
        return;
	}
};
```

#### 字符串的全排列

比如abc的全排列有abc,acb,bac,bca,cab,cba。

```
// 回溯法的想法
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>>res;
        sort(nums.begin(),nums.end());
        helper(res,nums,0);
        return res;
    }
    void helper(vector<vector<int>>&res,vector<int>nums,int i){
		if (i == nums.size() - 1) {
			res.push_back(nums);
			return;
		}
		for (int j = i; j < nums.size(); j++) {
			if ( i!=j && nums[j] == nums[i]) 
			// 如果有重复(但是本身是可以重复的 比如nums[i]==nums[i]) 则跳过
				continue;
			swap(nums[i], nums[j]);
			helper(res, nums, i+1);
		}
        return;
    }    
};
```



### 数组

#### 数组中找第一个重复的数字

长度为n的数组，数字范围是0~n-1，找第一个重复出现的数字。

使用桶：

```
class Solution {
public:

    // duplication: (Output) the duplicated number in the array number
    
    bool duplicate(int numbers[], int length, int* duplication) {
        vector<int> bucket(length,0);
        for(int i = 0; i < length; i++){
            if(bucket[numbers[i]]){
                *duplication = numbers[i];
                return true;
            }
            else{
                bucket[numbers[i]]++;
            }
        }
        return false;
    }
};
```

使用map/unordered_map（两者的对比，unordered_map可能更快，但是内存一般开销较大）

```
class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) {
        map<int,int> bucket;
        for(int i = 0; i < length; i++){
            if(bucket[numbers[i]]){
                *duplication = numbers[i];
                return true;
            }
            else{
                bucket[numbers[i]]++;
            }
        }
        return false;
    }
};
```

不使用额外空间：

```
class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) {
        for(int i = 0; i < length; i++){
            int index = abs(numbers[i]);
            if(numbers[index] >= 0){
                numbers[index] *= -1;
            }
            else if(numbers[index] < 0){
                * duplication = index;
                return true;
            }
        }
        // 如果找不到为负的，也可能是0重复了
        int count = 0;
        for(int i = 0; i < length; i++){
            if(numbers[i] == 0){
                count++;
                if(count > 1){
                    *duplication = 0;
                    return true;
                }
            }
        }
        return false;
    }
};
```



#### 构建乘积数组

给定数组A[0,1,2,...,n-1]，构建数组B[0,1,2,...,n-1]其中B[i]=A[0]\*A[1]*...\*A[i-1]\*A[i+1]...\*A[n-1].

```
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int n = A.size();
        vector<int> B(n,1);
        long long left = 1, right = 1; 
        // left计算从左到右的乘积，right计算从右到左。
        // 刚好当遍历到B[i]时，left和right都没有计算A[i]本身
        for(int i = 0; i < n; i++){
            B[i] *= left;
            B[n-i-1] *= right;
            left *= A[i];
            right *= A[n-i-1];
        }
        return B;
    }
};
```

#### 顺时针打印数组

有一个m\*n的数组，按照顺时针顺序把数组重组。

比如：

![image-20190329165709834](/Users/janhochoi/Library/Application Support/typora-user-images/image-20190329165709834.png)

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int row = matrix.size();
        if(!row) return res;
        int col = matrix[0].size();
        int top = 0, down = row - 1, left = 0, right = col - 1;
        int i = 0, j = 0;
        while(1){
            // 向右走
            while(j <= right){
                res.push_back(matrix[i][j]);
                j++;
            }
            j--;
            top += 1;
            if(++i > down) break;

            // 向下走
            while(i <= down){
                res.push_back(matrix[i][j]);
                i++;
            }
            i--;
            right -= 1;
            if(--j < left) break;

            // 向左走
            while(j >= left){
                res.push_back(matrix[i][j]);
                j--;
            }
            j++;
            down -= 1;
            if(--i < top) break;

            // 向上走
            while(i >= top){
                res.push_back(matrix[i][j]);
                i--;
            }
            i++;
            left += 1;
            if(++j > right) break;

        }
        return res;
    }
};
```

#### 在一个二维数组中找数

有一个二维数组，性质如下，每一行从左到右递增，每一列从上到下也递增。找target的数。

```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        if(m < 1) return false;
        int n = matrix[0].size();
        
        int i = 0, j = n-1; // 从右上角开始, 这样如果target小, 则向左走 target大则向下走
        while(i < m && j >= 0){
            if(matrix[i][j] < target){
                i += 1;
            }
            else if(matrix[i][j] > target){
                j -= 1;
            }
            else{
                return true;
            }
        }
        return false;
    }
};
```

#### 在旋转的一维有序数组中找到数

什么是旋转的一维有序数组：比如原来是0,1,2,3,4,5,6,7。现在变成了4,5,6,7,0,1,2,3。

总体思路：二分搜索+分类讨论。

一共有3种构成（先不考虑重复数）第一种是，有旋转，且mid在右边，比如5,6,0,1,2,3,4。第二种是，有旋转，且mid在左边，比如3,4,5,6,7,0,1,2。第三种是没有旋转，比如0,1,2,3,4,5。

先判断当前是哪一种，再去判断目标在左边还是右边。

第一个问题：

在这样的数组中，找到对应的数。（这个题目要求是无重复）

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() < 1)
            return -1;
        int left = 0, right = nums.size()-1;
        while(left <= right){
            int mid = (left+right)/2;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] > nums[right]){ // 有旋转 且mid在左边(较大边)
                if(target > nums[mid] || target <= nums[right])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
            else if(nums[mid] < nums[left]){ // 有旋转 且mid在右边(较小边)
                if(target < nums[mid] || target >= nums[left])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else{ // 没有旋转
                if(target > nums[mid])
                    left = mid+1;
                else
                    right = mid-1;
            }
        }
        return -1;
    }
};
```

第二个问题：

在这样的数组中找最小的：（数有可能重复）

```
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size()==0)
            return 0;
        int left = 0, right = rotateArray.size()-1;
        while(left < right){
            int mid = (left+right)/2;
            if(rotateArray[left] == rotateArray[mid]){
                left += 1; // 有重复直接把left++;
                continue;
            }
            if(rotateArray[right] == rotateArray[mid]){
                right -= 1; // 有重复直接把right--;
                continue;
            }
            
            if(rotateArray[mid] > rotateArray[right]){
                left = mid;
            }
            else{
                right = mid;
            }
        }
        return rotateArray[left];
    }
};
```

#### 排序：让奇数在偶数前面，且保证奇偶数本身的稳定性

```
// 类似插入排序的思想
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        int i = 0, k = 0;
        while(k < array.size()){
            if(array[k]%2){
                for(int temp = k; temp > i; temp--){
                    swap(array[temp],array[temp-1]);
                }
                i++;
            }
            k++;
        }
        return;
    }
};
```

#### 找数组中的众数

找数组中出现次数>size/2下取整的数。注意，这个数有可能不存在。

```
// 先用摩尔投票法 判断有可能是众数的这个数
// 再遍历一次数组 看这个数的出现次数是否满足众数要求
int majorityElement(vector<int>& nums) {
        if(nums.size() == 1)
            return nums[0];
        int count = 1, major = nums[0];
        for(int i = 1; i < nums.size(); i++){
            if(nums[i] == major)
                count++;
            else if(count > 0)
                count--;
            else{
                major = nums[i];
                count = 1;
            }
        }
        count = 0;
        for(int i = 0; i < nums.size(); i++)
        	if(nums[i] == major)
        		count++;
        		
        if(count > nums.size()/2) // 如果有解
            return major;
        else
            return -1;
    }
```

#### 找数组中的Top K元素

找到数据中Top K大/小的元素，也可能找第k个。

方法1：直接排序，然后输出前k个/第k个。

方法2：快排的思想。

方法3：堆排序的思想

```
class Solution {
public:
    
    // 建立一个容量为k的最小堆
    void min_heapify(vector<int> & nums, int start, int end){
        int father = start;
        int son = 2 * father + 1;
        while(son < end){
            if(son + 1 < end && nums[son] > nums[son+1])
                son++;
            if(nums[son] < nums[father]){
                swap(nums[son],nums[father]);
                father = son;
                son = 2 * father +1;
            }
            else
                return;
        }
        return;
    }

    int heapSortHelp(vector<int> & nums, int k){
        for(int i = k/2-1; i >= 0; i--){
            min_heapify(nums, i, k); // 先用数组前k个建堆
        }

        for(int i = k; i < nums.size(); i++){
            if(nums[i] < nums[0]){
                continue;
            }
            else{
                swap(nums[0],nums[i]);
                min_heapify(nums,0,k); // 然后每次交换之后都调整一次
            }
        }
        return nums[0];

    }

    int findKthLargest(vector<int>& nums, int k) {
        return heapSortHelp(nums,k);
    }
};
```

#### 给数组求最大连续子序列的和

比如[6,-3,-2,7,-15,1,2,2]，最大连续子序列就是6,-3,2,7。

```
// DP的思路，对每个元素来说，如果前面的最大子序列的和对我有利(>0)，那我就加入他们。
// 如果前面的和<0，那我就独善其身。
class Solution {
public:    
    int FindGreatestSumOfSubArray(vector<int> array) {
        int pre = array[0];
        int res = array[0];
        int size = array.size();
        for(int i = 1; i < size; i++){
            pre = max(pre+array[i],array[i]);
            res = max(pre,res);
        }
        return res;
    }
};
```



### 链表

#### 判断链表有没有环如果有环，找环的入口

```
前置证明
1. 首先快慢指针如果有环一定会相遇：当慢指针进入环后，情况可以看做快指针从环后面追慢指针（长跑的套圈）。若快与慢相差1（快在相对前进方向的后面），则显然下一步就可以追上。若快与慢相差2，下一步之后，可以转化为相差1的情况。若相差N步，可以转换为相差N-1步的情况，重复这个过程，一定可以追上。

2. 慢指针入圈后，快指针最多比慢指针多走一圈（快-慢<1圈）。由1可知，当慢指针进入了环之后，假设相差m步（0 <= m < 圈的长度），则根据1的结论，只需要走m步就可以了，所以快比慢多走了m，小于1圈的长度。

3. 相遇后继续走，如果再次相遇，用的步数即为圈的长度。

4. 相遇点一定在环入口。假设慢指针进入环中时，快指针需要m步（走m次）才能追上慢。第一次相遇时，慢指针也走了m步。所以s=a+m，a为head到环入口的距离，2s=a+m+n*环长，约去，得a=n*环长-m。此时，从起点走a步，相遇点也走a步，2s+a=a+2n*环长，恰好为环的起点。
```

```
node* findLoopPort(node *head) {
    node *fast, *slow;
    fast = slow = head;
    while (fast && fast->next) {  
//第一步：判断链表是否存在环
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { //链表存在环
            break;
        }
    }
    if ((fast == NULL) || (fast->next == NULL)) {  //链表不存在环
        return NULL;
    }
//第二步：寻找环的入口点
    slow = head; //让slow回到链表的起点，fast留在相遇点
    while (slow != fast) { //当slow和fast再次相遇时，那个点就是环的入口点
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

#### 在链表中删除所有重复节点

比如1->2->2->3->3->4，变成1->4。

注意有可能1->2->2->2...。

```
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next) return head; // 只有0/1个节点直接return
        
        ListNode res(0);
        res.next = head;
        ListNode * cur = &res; // cur是比较的两个节点的父亲。     
        while(cur->next && cur->next->next){
            if(cur->next->val == cur->next->next->val){
                int dupli = cur->next->val;
                while(cur->next && cur->next->val == dupli)
                    cur->next = cur->next->next; 
                // 出循环时, cur->next一定和dupli不同(要么为NULL要么为新值)
                // 相当于把原来相同的节点删去了
            }
            else{
                cur = cur->next; // 只改变cur 不改变cur->next
            }
        }
        return res.next;
    }
};
```

#### 倒序打印链表结点的值

比如链表是1-2-3-4-5，返回的结果要是5-4-3-2-1。直接用栈就好。

```
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        stack<int> s;
        while(head){
            s.push(head->val);
            head = head->next;
        }
        vector<int> res;
        while(!s.empty()){
            res.push_back(s.top());
            s.pop();
        }
        return res;
    }
};
```

#### 判断两个链表的第一个公共节点

思路：分别遍历两个链表，算出分别的长度l1和l2。（不妨设l1<l2）

然后指向长的链表的指针，先走l2-l1步，然后两个指针同时前进，迟早会相遇，相遇的节点就是第一个公共节点。（也可能不相遇，那么就没有公共节点）

#### 链表倒转

```
给定一个链表，比如1->2->3->4->5->null，让它变为5->4->3->2->1->null。
```

1. 递归

递归的语句是Function(head->next); // 让除了头后面的节点操作一遍。

操作完后，返回来的值head->next已经变成了最后一个节点，所以把head接到head->next后面，再让head->next=NULL即可。

退出的条件是head == NULL 和 head->next == NULL（看后面的语句用到了什么）。

1. 迭代

迭代把1->2->3变为2->1->3，再变为3->2->1；

```
// 迭代
    ListNode* reverseList(ListNode* head) {
        if(head == NULL)
            return NULL;
        ListNode * res = new ListNode(0); // res用来连接头节点
        res->next = head;
        ListNode * cur = head;
        ListNode * temp;
        while(cur->next != NULL){
            temp = cur->next->next;
            cur->next->next = res->next; // 把cur->next的下一个节点接到目前第一个节点
            res->next = cur->next; // 让cur->next称为新的第一个节点
            cur->next = temp; // cur作为最后一个节点，接回temp
            // 整个过程可以画图出来看
        }
        return res->next;
    }
```

#### 合并两个有序链表

```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode res(0);
        ListNode * cur = &res, * p1 = l1, * p2 = l2;
        while(p1 && p2){
            if(p1->val < p2->val){
                cur->next = p1;
                p1 = p1->next;
            }
            else{
                cur->next = p2;
                p2 = p2->next;
            }
            cur = cur->next;
        }
        if(p1) cur->next = p1;
        if(p2) cur->next = p2;
        return res.next;
    }
};
```

#### 复制一个随机链表

随机链表：一个节点除了next还有random指针，随机指向其中一个节点。

```
class Solution {
public:
    Node* copyRandomList(Node* head) {
        Node * head_copy = nullptr, * cur = head, * cur_copy = nullptr;
        if (head == nullptr)
            return nullptr;

        // 第一个循环把1-2-3-4...变成1-1-2-2-3-3-4-4...
        while(cur){
            cur_copy = new Node(cur->val, cur->next, nullptr); // 拷贝一个一样的节点
            cur->next = cur_copy; // 把拷贝的节点放在正常节点后面
            cur = cur_copy->next;
        }
        
        // 第二个循环 把拷贝的节点的随机节点分配好
        cur = head;
        while(cur){
            cur_copy = cur->next; // 此时cur->next刚好是拷贝的新节点
            if(cur->random){ // cur->random->next也是拷贝的cur->random
                cur_copy->random = cur->random->next;
            }
            cur = cur_copy->next;
        }

        // 第三个循环 把拷贝节点与原节点的连接断开
        cur = head;
        head_copy = head->next;
        while(cur){
            cur_copy = cur->next;
            cur->next = cur_copy->next; // 还原原来的连接
            if(cur->next)
                cur_copy->next = cur->next->next;
            cur = cur->next;
        }
        return head_copy;
    }
};
```



### 栈

#### 带有getMin()的栈

自己构造一个栈，但需要实现额外功能getMin()得到栈中最小元素。

```
class MinStack {
private:
    list<int> s1; // 存所有数
    list<int> s2; // 只存小数
public:
    思路：有两个数组，s1存所有数，s2只存历史的最小。因为是栈，所以在最小数出栈之前，最小不会改变。
    
    MinStack() {}
    // 入栈
    void push(int x) {
        s1.push_back(x);
        if(s2.empty() || x <= s2.back()) // 注意这里要<=，否则很可能在pop的时候误把s2也出栈。
            s2.push_back(x);
    }
    // 出栈
    void pop() {
        if(s1.back() == s2.back())
            s2.pop_back();
        s1.pop_back();
    }
    // 返回栈顶元素
    int top() {
        return s1.back();
    }
    // 返回最小的元素
    int getMin() {
        return s2.back();
    }
};
```

#### 给定入栈、出栈序列，判断能不能实现

比如入栈是1,2,3,4,5，出栈是5,4,3,2,1，则这两个序列是可以实现的。

如果出栈是4,3,5,1,2就不可能。

```
// 思路：作一个模拟栈 每入栈一个新数 都判断能不能出 能出就一直出 直到最后看看能不能出完
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> s;
        int i = 0, j = 0;
        for(i = 0; i < pushed.size(); i++){
            s.push(pushed[i]); // 第i个元素入栈
            while(j < popped.size() && !s.empty() && s.top() == popped[j]){ // 如果符合要求直接出栈
                s.pop();
                j++;
            }
        }
        if(j == popped.size())
            return true;
        else
            return false;
    }
};
```

#### 用两个栈实现queue的基本功能

用两个栈实现queue的push/pop/empty/peek几个功能。

```
// 思路：如果要pop或者找队头元素 则把s1的元素pop出 并按pop的顺序压入s2里面 s2即为队列的顺序
class MyQueue {
private:
    stack<int> s1; // s1用来push 以及为s2提供数
    stack<int> s2; // s2用来pop
public:
    /** Initialize your data structure here. */
    MyQueue() {
        
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(s2.empty()){
            while(!s1.empty()){
                s2.push(s1.top());
                s1.pop();
            }
        }
        int res = s2.top();
        s2.pop();
        return res;
    }
    
    /** Get the front element. */
    int peek() {
        if(s2.empty()){
            while(!s1.empty()){
                s2.push(s1.top());
                s1.pop();
            }
        }
        int res = s2.top();
        return res;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        if(s1.empty()&&s2.empty())
            return true;
        else
            return false;
    }
};
```





### 斐波那契

#### 输出斐波那契数列第n项

憨憨题。也可以用递归，不过有丶憨。

```
class Solution {
public:
    int Fibonacci(int n) {
        if(n == 0)
            return 0;
        int i = 0, j = 1;
        for(int k = 1; k < n; k++){
            int temp = i;
            i = j;
            j = temp + j;
        }
        return j;
    }
};
```

#### 跳台阶

一次可以跳上1级台阶，也可以跳上2级。求跳n级有多少种跳法。

```
class Solution {
public:
    int climbStairs(int n) {
        int res = 1;
        int before2 = 1, before1 = 1;
        while(--n > 0){
            res = before2 + before1;
            before2 = before1;
            before1 = res;
        }
        return res;
    }
};
```

#### 跳台阶2

现在一次可以跳上1级，也可以跳上2级，也可以跳上3级，也可以跳上n级。求一共有多少种跳法。

```
// 思路：f(0) = 1
		f(1) = f(0)
		f(2) = f(1) + f(0) = 2f(0)
		f(3) = f(2) + f(1) + f(0) = 4f(0)
		所以f(n) = 2^(n-1)*f(0)
class Solution {
public:
    int climbStairs2(int n) {
        int res = 1;
        for(int i = 1; i < n; i++){
            res *= 2;
        }
        return res;
    }
};
```

#### 小矩形覆盖

用2\*1的小矩形无重叠的横向/竖向覆盖一个更大的矩形。

```
n=1 - 只有横放一个矩形一种解决办法 
n=2 - 有横放一个矩形，竖放两个矩形两种解决办法 
n=3 - n=2的基础上加1个横向，n=1的基础上加2个竖向 
n=4 - n=3的基础上加1个横向，n=2的基础上加2个竖向 
```

```
// 其实就是斐波那契的起始项变了一点
class Solution {
public:
    int rectCover(int number) {
        if(number == 0) return 0;
        int i = 1, j = 1;
        for(int k = 1; k < number; k++){
            int temp = i;
            i = j;
            j = temp + j;
        }
        return j;
    }
};
```

### 大整数系列

#### Pow(x,n)

```
// 迭代法
class Solution {
public:
    double myPow(double x, int n) {
        if(n == 0) return 1;
        if(x == 0 || x == 1) return x; // 特殊情况直接处理掉
        double res = 1;
        long long count = n; // 避免n=INT_MIN时无法直接取负 先处理成ll类型
        if(n < 0){
            x = 1/x;
            count = -count;
        }
        double temp = x;
        while(count){
            if(count & 1)
                res *= temp;
            temp *= temp;
            count >>= 1;
        }
        return res;
    }
};
```

```
// 递归法
class Solution {
public:
    double myPow(double x, int n) {
        if(n == 0) return 1;
        if(n == 1) return x;
        if(x == 0 || x == 1) return x; // 特殊情况直接处理掉
        double temp = myPow(x,n/2);
        if(n%2 == 0) return temp*temp;
        else return (n<0)? 1/x*temp*temp : x*temp*temp;
    }
};
```

### 数字游戏

#### 从0~n中数字1出现的次数

比如13，有01/10/11/12/13一共出现了六次。

```
class Solution
{
  public:
    int countDigitOne(int n)
    {   // n>=0
        int res = 0;
        for(long factor = 1; factor <= n; factor *= 10){
		    int currentNum = (n / factor) % 10; // 当前判断的位的值
		    int highNum = (n / factor)/10; // 截去当前位及后面所有，剩下前面所有位的值
		    int lowNum = n % factor; // 当前位后面的所有位的值
		
		    switch(currentNum){
			    case 0: // 当前位是0 则为高位*factor(比如10) 如34|02 出现在十位的1有34(00~33)*10(后面的位有factor个可能)种可能性。
				    res += highNum * factor;
				    break;
			    case 1: // 比如34|12 出现在十位的1有34*factor(10) (0000~3400) + 2(3411和3412) + 1(3410)
				    res += highNum * factor + lowNum + 1; // 即 |1|xxxx个数=xxxx+1
				    break;
			    default: // 比如34|22 出现在十位的1有(34+1)*factor (00 ~ 34)
				    res += (highNum + 1) * factor;
				    break;
		    }
	    }
        return res;
    }
};
```

#### 把数组合并成最小的数

比如3/32/321最小的就是321323。



### 快慢指针应用

```
快慢指针意思是，有一快一慢两个指针，每次循环一个走一步，一个走两步。
```

1. 判断单链表是否有环

如果有环，那么快慢指针肯定会相遇的。每次循环快指针比慢指针多走1步，只要多走了k步其中k是环的大小。那么就会相遇。

```
bool hasCircle(TreeNode * root){
	if(root == NULL)
		return false; // 特殊判断
    TreeNode * fast = root;
    TreeNode * slow = root;
    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;
        if(fast == slow)
        	return true;
    }
    return false;
}
```

2. 在有序链表中寻找中位数

因为快指针速度是慢指针的两倍，所以快指针到达最后的时候，慢指针刚好在中位。

需要注意的是，要判断单双数。

```
while(fast != NULL && slow != NULL){
    if(fast->next == NULL){	// 1+2x = k k为单数个节点
        // 此时fast已经是最后一个节点 slow = 1+x
        return slow->data;
    }
    else if(fast->next->next == NULL){	// 1+2x+1 = k k为单数个节点
    	// 此时slow = 1+x 所以是中位数中偏左的节点
        return (slow->data + slow->next->data)/2;
    }
    else{
        fast = fast->next->next;
        slow = slow->next;
    }
}
```

3. 寻找链表中的倒数第K个节点。

定义两个指针，其中一个指针先走K步，然后两个指针一步一步走，当前面的指针到达NULL，则此时后面的指针刚好指向倒数第K个节点。

```
// 查找单链表中倒数第K个结点  
ListNode * RGetKthNode(ListNode * pHead, unsigned int k) // 函数名前面的R代表反向  
{  
    if(k == 0 || pHead == NULL) // 这里k的计数是从1开始的，若k为0或链表为空返回NULL  
        return NULL;  
  
    ListNode * pAhead = pHead;	// 注意在这里相当于先走了一步
    ListNode * pBehind = pHead;  
    for(int i=0;i<k-1;i++){  // 一开始先走了一步.所以现在只要走k-1步
        pAhead=pAhead->next;  
        if(pAhead==null)  return null; //当链表长度小于k时候，返回Null  
    }  
    while(pAhead->next != NULL)  // 前后两个指针一起向前走，直到前面的指针指向最后一个结点，这里的判断方式是pAhead->next，此时pAhead->next领先pBehind刚好K步
    {  
        pBehind = pBehind->next;  
        pAhead = pAhead->next;  
    }  
    return pBehind;  // 后面的指针所指结点就是倒数第k个结点  
} 
```

4. 判断链表是否存在环，如果存在，找到环入口。

```
前置证明
1. 首先快慢指针如果有环一定会相遇：当慢指针进入环后，情况可以看做快指针从环后面追慢指针（长跑的套圈）。若快与慢相差1（快在相对前进方向的后面），则显然下一步就可以追上。若快与慢相差2，下一步之后，可以转化为相差1的情况。若相差N步，可以转换为相差N-1步的情况，重复这个过程，一定可以追上。

2. 慢指针入圈后，快指针最多比慢指针多走一圈（快-慢<1圈）。由1可知，当慢指针进入了环之后，假设相差m步（0 <= m < 圈的长度），则根据1的结论，只需要走m步就可以了，所以快比慢多走了m，小于1圈的长度。

3. 相遇后继续走，如果再次相遇，用的步数即为圈的长度。

4. 相遇点一定在环入口。假设慢指针进入环中时，快指针需要m步（走m次）才能追上慢。第一次相遇时，慢指针也走了m步。所以s=a+m，a为head到环入口的距离，2s=a+m+n*环长，约去，得a=n*环长-m。此时，从起点走a步，相遇点也走a步，2s+a=a+2n*环长，恰好为环的起点。
```

```
node* findLoopPort(node *head) {
    node *fast, *slow;
    fast = slow = head;
    while (fast && fast->next) {  
//第一步：判断链表是否存在环
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { //链表存在环
            break;
        }
    }
    if ((fast == NULL) || (fast->next == NULL)) {  //链表不存在环
        return NULL;
    }
//第二步：寻找环的入口点
    slow = head; //让slow回到链表的起点，fast留在相遇点
    while (slow != fast) { //当slow和fast再次相遇时，那个点就是环的入口点
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

5. 判断两个单链表是否相交，如果相交，找第一个公共节点。

首先用快慢指针判断两个表是否有环。如果一个有环一个无环，则不可能相交。如果两个都有环，则判断任意一个链表上快慢指针相遇的那个节点，在不在另外一个链表上，如果在，则相交，不在，则不相交。

首先两个链表各遍历一次，求出两个链表的长度L1、L2，然后可以得到它们的长度差L。然后现在长的链表上遍历L个节点，之后再同步遍历，于是在遍历中，第一个相同的节点就是第一个公共的节点。此时，若两个链表长度分别为M，N,则时间复杂度为O(M+N)。

### 数组中第K大的数

```
给一个未排序的数组，找出其中第k大的数。
```

1. 直接排序。

排序之后遍历前k个元素。时间复杂度：O(nlogn+k)。空间复杂度：O(1)。

2. 最小堆

先用k个元素建立最小堆，然后向后遍历，如果nums[i]比堆顶大，那么证明，nums[i]可能是前k个大，然后进堆，调整最小堆。一直遍历完，最小堆最上面的数，就是最大的k个数中最小的。

```
// 建立一个容量为k的最小堆
    void min_heapify(vector<int> & nums, int start, int end){
        int father = start;
        int son = 2 * father + 1;
        while(son < end){
            if(son + 1 < end && nums[son] > nums[son+1])
                son++;
            if(nums[son] < nums[father]){
                swap(nums[son],nums[father]);
                father = son;
                son = 2 * father +1;
            }
            else
                return;
        }
        return;
    }

    int heapSortHelp(vector<int> & nums, int k){
        for(int i = k/2-1; i >= 0; i--){
            min_heapify(nums, i, k);
        }

        for(int i = k; i < nums.size(); i++){
            if(nums[i] < nums[0]){
                continue;
            }
            else{
                swap(nums[0],nums[i]);
                min_heapify(nums,0,k);
            }
        }
        return nums[0];

    }
```

2. 快速排序

先判断pivot是第x大，然后如果根据x和K的关系，去检查左边或者右边。

最优情况：刚好每次pivot都在中间，则时间复杂度是O(n+n/2+n/4....) = O(n)

情况很差，每次pivot都在两侧，则O(n + n-1 + n-2 ...) = O(n2) 

```
class Solution {
public:
    // 快排的想法
    int quickSortHelp(vector<int>& nums, int k, int start, int end){
        int n = end - start; // n表示的是数组一共有多少个数
        if(n==1)
            return nums[start];
        int left = start;
        int right = end-1;
        int index = nums[left];
        while(left < right){
            while(nums[right] >= index && right > left){
                right--;
            }
            nums[left] = nums[right];
            while(nums[left] <= index && left < right){
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = index;
        if(n - (left-start) == k) // n-(left-start)表示第x大
            return index;
        else if(n - (left-start) > k){
            return quickSortHelp(nums, k, left+1, end);
        }
        else{
            return quickSortHelp(nums, k-(n-(left-start)), start, left);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        return quickSortHelp(nums,k,0,nums.size());
    }
};
```

### 判断图是否联通（判断是不是从某个点开始所有点都可以访问到）

bfs：

设立isVisited[]，表示所有的点是否访问过。

把开始点入栈。

出栈，栈顶为v，若isVisited[v]=0，表明v点还没访问过，令isVisited[v]=1，然后把与v相连的点入栈。如果isVisited[v]=1，表明这个点之前已经访问过，continue。

循环这一步，直到栈里面没有点。然后统计isVisited[]，看有没有点漏掉。

dfs：

设立isVisited[]，表示所有的点是否访问过。

选一个开始点v。令isVisited[v] = 1，遍历与v相邻的所有边，不妨设其中u与v相连，如果isVisited[u]=1，那么跳过，否则，递归执行dfs(u)。

```
void DFS(MGrap G. int i)
{
    int j = 0;
    visited[i] = 1;
    for(j=0; j<G.numVertexes; j++)
    {
        if(G.arc[i][j]==1 && !visited[j])//i和j有关系相邻，并且j顶点没有被访问过
        {
            DFS(G, j);
        }
    }
}
```

